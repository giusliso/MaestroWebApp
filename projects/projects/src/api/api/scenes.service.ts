/**
 * MaestroHost - SceneService
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Content } from '../model/content';
import { ErrorResponse } from '../model/errorResponse';
import { LearningPath } from '../model/learningPath';
import { Scenario } from '../model/scenario';
import { Scene } from '../model/scene';
import { Target } from '../model/target';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ScenesService {

    protected basePath = 'https://localhost/{{basepath}}/SceneService/{{version}}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param contentId 
     * @param fileId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Content>;
    public addContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Content>>;
    public addContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Content>>;
    public addContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling addContentFile.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling addContentFile.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling addContentFile.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling addContentFile.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling addContentFile.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<Content>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents/${encodeURIComponent(String(contentId))}/files/${encodeURIComponent(String(fileId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param learningPathId 
     * @param targetId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<LearningPath>;
    public addLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LearningPath>>;
    public addLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LearningPath>>;
    public addLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling addLearningPathTarget.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling addLearningPathTarget.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling addLearningPathTarget.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling addLearningPathTarget.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling addLearningPathTarget.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<LearningPath>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths/${encodeURIComponent(String(learningPathId))}/targets/${encodeURIComponent(String(targetId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param scenarioId 
     * @param learningPathId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Scenario>;
    public addScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scenario>>;
    public addScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scenario>>;
    public addScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling addScenarioLearningPath.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling addScenarioLearningPath.');
        }

        if (scenarioId === null || scenarioId === undefined) {
            throw new Error('Required parameter scenarioId was null or undefined when calling addScenarioLearningPath.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling addScenarioLearningPath.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling addScenarioLearningPath.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<Scenario>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios/${encodeURIComponent(String(scenarioId))}/learningPaths/${encodeURIComponent(String(learningPathId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param targetId 
     * @param contentId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Target>;
    public addTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Target>>;
    public addTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Target>>;
    public addTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling addTargetContent.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling addTargetContent.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling addTargetContent.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling addTargetContent.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling addTargetContent.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<Target>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets/${encodeURIComponent(String(targetId))}/contents/${encodeURIComponent(String(contentId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param newContent 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createContent(login: string, sceneId: number, newContent: Content, version: string, observe?: 'body', reportProgress?: boolean): Observable<Content>;
    public createContent(login: string, sceneId: number, newContent: Content, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Content>>;
    public createContent(login: string, sceneId: number, newContent: Content, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Content>>;
    public createContent(login: string, sceneId: number, newContent: Content, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling createContent.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling createContent.');
        }

        if (newContent === null || newContent === undefined) {
            throw new Error('Required parameter newContent was null or undefined when calling createContent.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createContent.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Content>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents`,
            newContent,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param newLearningPath 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createLearningPath(login: string, sceneId: number, newLearningPath: LearningPath, version: string, observe?: 'body', reportProgress?: boolean): Observable<LearningPath>;
    public createLearningPath(login: string, sceneId: number, newLearningPath: LearningPath, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LearningPath>>;
    public createLearningPath(login: string, sceneId: number, newLearningPath: LearningPath, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LearningPath>>;
    public createLearningPath(login: string, sceneId: number, newLearningPath: LearningPath, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling createLearningPath.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling createLearningPath.');
        }

        if (newLearningPath === null || newLearningPath === undefined) {
            throw new Error('Required parameter newLearningPath was null or undefined when calling createLearningPath.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createLearningPath.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<LearningPath>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths`,
            newLearningPath,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param newScenario 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createScenario(login: string, sceneId: number, newScenario: Scenario, version: string, observe?: 'body', reportProgress?: boolean): Observable<Scenario>;
    public createScenario(login: string, sceneId: number, newScenario: Scenario, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scenario>>;
    public createScenario(login: string, sceneId: number, newScenario: Scenario, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scenario>>;
    public createScenario(login: string, sceneId: number, newScenario: Scenario, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling createScenario.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling createScenario.');
        }

        if (newScenario === null || newScenario === undefined) {
            throw new Error('Required parameter newScenario was null or undefined when calling createScenario.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createScenario.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Scenario>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios`,
            newScenario,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param newScene 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createScene(login: string, newScene: Scene, observe?: 'body', reportProgress?: boolean): Observable<Scene>;
    public createScene(login: string, newScene: Scene, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scene>>;
    public createScene(login: string, newScene: Scene, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scene>>;
    public createScene(login: string, newScene: Scene, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling createScene.');
        }

        if (newScene === null || newScene === undefined) {
            throw new Error('Required parameter newScene was null or undefined when calling createScene.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Scene>(`${this.basePath}/Scenes`,
            newScene,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param newTarget 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTarget(login: string, sceneId: number, newTarget: Target, version: string, observe?: 'body', reportProgress?: boolean): Observable<Target>;
    public createTarget(login: string, sceneId: number, newTarget: Target, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Target>>;
    public createTarget(login: string, sceneId: number, newTarget: Target, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Target>>;
    public createTarget(login: string, sceneId: number, newTarget: Target, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling createTarget.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling createTarget.');
        }

        if (newTarget === null || newTarget === undefined) {
            throw new Error('Required parameter newTarget was null or undefined when calling createTarget.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createTarget.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Target>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets`,
            newTarget,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param contentId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteContent(login: string, sceneId: number, contentId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteContent(login: string, sceneId: number, contentId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteContent(login: string, sceneId: number, contentId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteContent(login: string, sceneId: number, contentId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling deleteContent.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling deleteContent.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling deleteContent.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteContent.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents/${encodeURIComponent(String(contentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param fileId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFile(login: string, sceneId: number, fileId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteFile(login: string, sceneId: number, fileId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteFile(login: string, sceneId: number, fileId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteFile(login: string, sceneId: number, fileId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling deleteFile.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling deleteFile.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling deleteFile.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/files/${encodeURIComponent(String(fileId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param learningPathId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling deleteLearningPath.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling deleteLearningPath.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling deleteLearningPath.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteLearningPath.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths/${encodeURIComponent(String(learningPathId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param scenarioId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteScenario(login: string, sceneId: number, scenarioId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteScenario(login: string, sceneId: number, scenarioId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteScenario(login: string, sceneId: number, scenarioId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteScenario(login: string, sceneId: number, scenarioId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling deleteScenario.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling deleteScenario.');
        }

        if (scenarioId === null || scenarioId === undefined) {
            throw new Error('Required parameter scenarioId was null or undefined when calling deleteScenario.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteScenario.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios/${encodeURIComponent(String(scenarioId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteScene(login: string, sceneId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteScene(login: string, sceneId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteScene(login: string, sceneId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteScene(login: string, sceneId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling deleteScene.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling deleteScene.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param targetId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTarget(login: string, sceneId: number, targetId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteTarget(login: string, sceneId: number, targetId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteTarget(login: string, sceneId: number, targetId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteTarget(login: string, sceneId: number, targetId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling deleteTarget.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling deleteTarget.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling deleteTarget.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteTarget.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets/${encodeURIComponent(String(targetId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param fileId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadFileAsync(login: string, sceneId: number, fileId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadFileAsync(login: string, sceneId: number, fileId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadFileAsync(login: string, sceneId: number, fileId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadFileAsync(login: string, sceneId: number, fileId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling downloadFileAsync.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling downloadFileAsync.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling downloadFileAsync.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/files/${encodeURIComponent(String(fileId))}/content`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param contentId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContent(login: string, sceneId: number, contentId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Content>;
    public getContent(login: string, sceneId: number, contentId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Content>>;
    public getContent(login: string, sceneId: number, contentId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Content>>;
    public getContent(login: string, sceneId: number, contentId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getContent.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getContent.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling getContent.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getContent.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Content>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents/${encodeURIComponent(String(contentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContents(login: string, sceneId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Content>>;
    public getContents(login: string, sceneId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Content>>>;
    public getContents(login: string, sceneId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Content>>>;
    public getContents(login: string, sceneId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getContents.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getContents.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getContents.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Content>>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param fileId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFileData(login: string, sceneId: number, fileId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getFileData(login: string, sceneId: number, fileId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getFileData(login: string, sceneId: number, fileId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getFileData(login: string, sceneId: number, fileId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getFileData.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getFileData.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling getFileData.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/files/${encodeURIComponent(String(fileId))}/data`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param learningPathId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<LearningPath>;
    public getLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LearningPath>>;
    public getLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LearningPath>>;
    public getLearningPath(login: string, sceneId: number, learningPathId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getLearningPath.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getLearningPath.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling getLearningPath.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getLearningPath.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LearningPath>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths/${encodeURIComponent(String(learningPathId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLearningPaths(login: string, sceneId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Array<LearningPath>>;
    public getLearningPaths(login: string, sceneId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LearningPath>>>;
    public getLearningPaths(login: string, sceneId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LearningPath>>>;
    public getLearningPaths(login: string, sceneId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getLearningPaths.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getLearningPaths.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getLearningPaths.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<LearningPath>>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param scenarioId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getScenario(login: string, sceneId: number, scenarioId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Scenario>;
    public getScenario(login: string, sceneId: number, scenarioId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scenario>>;
    public getScenario(login: string, sceneId: number, scenarioId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scenario>>;
    public getScenario(login: string, sceneId: number, scenarioId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getScenario.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getScenario.');
        }

        if (scenarioId === null || scenarioId === undefined) {
            throw new Error('Required parameter scenarioId was null or undefined when calling getScenario.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getScenario.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Scenario>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios/${encodeURIComponent(String(scenarioId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getScenarios(login: string, sceneId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Scenario>>;
    public getScenarios(login: string, sceneId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Scenario>>>;
    public getScenarios(login: string, sceneId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Scenario>>>;
    public getScenarios(login: string, sceneId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getScenarios.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getScenarios.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getScenarios.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Scenario>>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param fullScene 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getScene(login: string, sceneId: number, fullScene: boolean, observe?: 'body', reportProgress?: boolean): Observable<Scene>;
    public getScene(login: string, sceneId: number, fullScene: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scene>>;
    public getScene(login: string, sceneId: number, fullScene: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scene>>;
    public getScene(login: string, sceneId: number, fullScene: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getScene.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getScene.');
        }

        if (fullScene === null || fullScene === undefined) {
            throw new Error('Required parameter fullScene was null or undefined when calling getScene.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fullScene !== undefined && fullScene !== null) {
            queryParameters = queryParameters.set('fullScene', <any>fullScene);
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/octet-stream'
        ];

        return this.httpClient.get<Scene>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param targetId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTarget(login: string, sceneId: number, targetId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Target>;
    public getTarget(login: string, sceneId: number, targetId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Target>>;
    public getTarget(login: string, sceneId: number, targetId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Target>>;
    public getTarget(login: string, sceneId: number, targetId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getTarget.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getTarget.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling getTarget.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTarget.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Target>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets/${encodeURIComponent(String(targetId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTargets(login: string, sceneId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Target>>;
    public getTargets(login: string, sceneId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Target>>>;
    public getTargets(login: string, sceneId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Target>>>;
    public getTargets(login: string, sceneId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling getTargets.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling getTargets.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTargets.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Target>>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param contentId 
     * @param fileId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Content>;
    public removeContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Content>>;
    public removeContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Content>>;
    public removeContentFile(login: string, sceneId: number, contentId: number, fileId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling removeContentFile.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling removeContentFile.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling removeContentFile.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling removeContentFile.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling removeContentFile.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<Content>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents/${encodeURIComponent(String(contentId))}/files/${encodeURIComponent(String(fileId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param learningPathId 
     * @param targetId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<LearningPath>;
    public removeLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LearningPath>>;
    public removeLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LearningPath>>;
    public removeLearningPathTarget(login: string, sceneId: number, learningPathId: number, targetId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling removeLearningPathTarget.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling removeLearningPathTarget.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling removeLearningPathTarget.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling removeLearningPathTarget.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling removeLearningPathTarget.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<LearningPath>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths/${encodeURIComponent(String(learningPathId))}/targets/${encodeURIComponent(String(targetId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param scenarioId 
     * @param learningPathId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Scenario>;
    public removeScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scenario>>;
    public removeScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scenario>>;
    public removeScenarioLearningPath(login: string, sceneId: number, scenarioId: number, learningPathId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling removeScenarioLearningPath.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling removeScenarioLearningPath.');
        }

        if (scenarioId === null || scenarioId === undefined) {
            throw new Error('Required parameter scenarioId was null or undefined when calling removeScenarioLearningPath.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling removeScenarioLearningPath.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling removeScenarioLearningPath.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<Scenario>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios/${encodeURIComponent(String(scenarioId))}/learningPaths/${encodeURIComponent(String(learningPathId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param targetId 
     * @param contentId 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe?: 'body', reportProgress?: boolean): Observable<Target>;
    public removeTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Target>>;
    public removeTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Target>>;
    public removeTargetContent(login: string, sceneId: number, targetId: number, contentId: number, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling removeTargetContent.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling removeTargetContent.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling removeTargetContent.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling removeTargetContent.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling removeTargetContent.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<Target>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets/${encodeURIComponent(String(targetId))}/contents/${encodeURIComponent(String(contentId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param contentId 
     * @param updatedContent 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateContent(login: string, sceneId: number, contentId: number, updatedContent: Content, version: string, observe?: 'body', reportProgress?: boolean): Observable<Content>;
    public updateContent(login: string, sceneId: number, contentId: number, updatedContent: Content, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Content>>;
    public updateContent(login: string, sceneId: number, contentId: number, updatedContent: Content, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Content>>;
    public updateContent(login: string, sceneId: number, contentId: number, updatedContent: Content, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling updateContent.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling updateContent.');
        }

        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling updateContent.');
        }

        if (updatedContent === null || updatedContent === undefined) {
            throw new Error('Required parameter updatedContent was null or undefined when calling updateContent.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateContent.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Content>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/contents/${encodeURIComponent(String(contentId))}`,
            updatedContent,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param learningPathId 
     * @param updatedLearningPath 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateLearningPath(login: string, sceneId: number, learningPathId: number, updatedLearningPath: LearningPath, version: string, observe?: 'body', reportProgress?: boolean): Observable<LearningPath>;
    public updateLearningPath(login: string, sceneId: number, learningPathId: number, updatedLearningPath: LearningPath, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LearningPath>>;
    public updateLearningPath(login: string, sceneId: number, learningPathId: number, updatedLearningPath: LearningPath, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LearningPath>>;
    public updateLearningPath(login: string, sceneId: number, learningPathId: number, updatedLearningPath: LearningPath, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling updateLearningPath.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling updateLearningPath.');
        }

        if (learningPathId === null || learningPathId === undefined) {
            throw new Error('Required parameter learningPathId was null or undefined when calling updateLearningPath.');
        }

        if (updatedLearningPath === null || updatedLearningPath === undefined) {
            throw new Error('Required parameter updatedLearningPath was null or undefined when calling updateLearningPath.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateLearningPath.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<LearningPath>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/learningPaths/${encodeURIComponent(String(learningPathId))}`,
            updatedLearningPath,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param scenarioId 
     * @param updatedScenario 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateScenario(login: string, sceneId: number, scenarioId: number, updatedScenario: Scenario, version: string, observe?: 'body', reportProgress?: boolean): Observable<Scenario>;
    public updateScenario(login: string, sceneId: number, scenarioId: number, updatedScenario: Scenario, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scenario>>;
    public updateScenario(login: string, sceneId: number, scenarioId: number, updatedScenario: Scenario, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scenario>>;
    public updateScenario(login: string, sceneId: number, scenarioId: number, updatedScenario: Scenario, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling updateScenario.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling updateScenario.');
        }

        if (scenarioId === null || scenarioId === undefined) {
            throw new Error('Required parameter scenarioId was null or undefined when calling updateScenario.');
        }

        if (updatedScenario === null || updatedScenario === undefined) {
            throw new Error('Required parameter updatedScenario was null or undefined when calling updateScenario.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateScenario.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Scenario>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/scenarios/${encodeURIComponent(String(scenarioId))}`,
            updatedScenario,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param updatedScene 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateScene(login: string, sceneId: number, updatedScene: Scene, observe?: 'body', reportProgress?: boolean): Observable<Scene>;
    public updateScene(login: string, sceneId: number, updatedScene: Scene, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Scene>>;
    public updateScene(login: string, sceneId: number, updatedScene: Scene, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Scene>>;
    public updateScene(login: string, sceneId: number, updatedScene: Scene, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling updateScene.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling updateScene.');
        }

        if (updatedScene === null || updatedScene === undefined) {
            throw new Error('Required parameter updatedScene was null or undefined when calling updateScene.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Scene>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}`,
            updatedScene,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param targetId 
     * @param updatedTarget 
     * @param version 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTarget(login: string, sceneId: number, targetId: number, updatedTarget: Target, version: string, observe?: 'body', reportProgress?: boolean): Observable<Target>;
    public updateTarget(login: string, sceneId: number, targetId: number, updatedTarget: Target, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Target>>;
    public updateTarget(login: string, sceneId: number, targetId: number, updatedTarget: Target, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Target>>;
    public updateTarget(login: string, sceneId: number, targetId: number, updatedTarget: Target, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling updateTarget.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling updateTarget.');
        }

        if (targetId === null || targetId === undefined) {
            throw new Error('Required parameter targetId was null or undefined when calling updateTarget.');
        }

        if (updatedTarget === null || updatedTarget === undefined) {
            throw new Error('Required parameter updatedTarget was null or undefined when calling updateTarget.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateTarget.');
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Target>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/targets/${encodeURIComponent(String(targetId))}`,
            updatedTarget,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param login 
     * @param sceneId 
     * @param name 
     * @param description 
     * @param extension 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadFileAsync(login: string, sceneId: number, name: string, description: string, extension: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public uploadFileAsync(login: string, sceneId: number, name: string, description: string, extension: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public uploadFileAsync(login: string, sceneId: number, name: string, description: string, extension: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public uploadFileAsync(login: string, sceneId: number, name: string, description: string, extension: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling uploadFileAsync.');
        }

        if (sceneId === null || sceneId === undefined) {
            throw new Error('Required parameter sceneId was null or undefined when calling uploadFileAsync.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling uploadFileAsync.');
        }

        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling uploadFileAsync.');
        }

        if (extension === null || extension === undefined) {
            throw new Error('Required parameter extension was null or undefined when calling uploadFileAsync.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (description !== undefined && description !== null) {
            queryParameters = queryParameters.set('description', <any>description);
        }
        if (extension !== undefined && extension !== null) {
            queryParameters = queryParameters.set('extension', <any>extension);
        }

        let headers = this.defaultHeaders;
        if (login !== undefined && login !== null) {
            headers = headers.set('login', String(login));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/Scenes/${encodeURIComponent(String(sceneId))}/files`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
